## UNO Activity — MVP План

### Мета
Створити Discord Activity (Embedded App), що дозволяє 2+ гравцям грати у спрощене UNO з числовими картами 4 кольорів, по черзі, без бонус‑карт.

### Джерела
- Discord Quick Start — Getting Started: https://discord.com/developers/docs/quick-start/getting-started
- Discord Docs — Intro: https://discord.com/developers/docs/intro

### Архітектура
- Клієнт (Embedded App SDK): інтерфейс столу, підключення до бекенду, отримання контексту Activity (користувач, канал/гільдія).
- Бекенд (WebSocket, авторитетний сервер): кімнати-матчі, правила колоди/ходу, приховані руки, синхронізація стану, снапшот при реконекті.
- Зберігання: in‑memory (MVP), без персистентності. Опційно — сидований shuffle.

### Обсяг MVP (Ruleset)
- Гравці: 2–6 у матчі (ціль — 2+).
- Колода: лише цифри 0–9 чотирьох кольорів; для кожного кольору 1×0 та 2×(1–9).
- Роздача: 7 карт кожному. Перша карта у відбої має бути числова.
- Хід: дозволено покласти карту, що збігається за кольором або числом з верхньою у відбої.
- Якщо немає ходу: тягнеш 1 карту; якщо зіграбельна — можна одразу зіграти; інакше — пас.
- Перемога: рука порожня → кінець матчу.

### Потік сесії
1. Хост створює матч (кімнату) в Activity у голосовому каналі.
2. Гравці приєднуються, позначають готовність, старт.
3. Сервер роздає, визначає порядок ходу, валідуює дії.
4. Події у реальному часі: play/draw/pass; бродкаст снапшотів і дифів стану.
5. Реконект/пізнє підключення: сервер віддає актуальний снапшот із прихованими картами інших.

### Безпека й чесність
- Авторитетний сервер: валідація ходів, генерація та тасування колоди.
- Приховані руки: клієнти отримують лише дозволену інформацію.
- Сидований shuffle (репрод’юсибельність); таймаути ходу (опціонально для MVP).

### Технічні задачі (високий рівень)
1. Увімкнути Embedded App і налаштувати allowed origins у Discord Portal.
2. Скелет клієнта Activity (React/Vite) з Embedded App SDK.
3. Бекенд Node.js (Express/Fastify) з WebSocket‑кімнатами.
4. Правила UNO (numeric): колода, роздача, валідація ходу, перемога.
5. Життєвий цикл гри: create/join/start/end.
6. Події real‑time: play/draw/pass, state snapshot/patch.
7. UI: лобі й стіл (рука гравця, верхня карта, індикатор ходу).
8. Activity launch flow: отримання контексту, ідентифікація користувачів.
9. Реконект і late‑join: синхронізація стану.
10. Локальна розробка: .env, ngrok, npm scripts.
11. Мінімальні тести правил і черги ходу.
12. Інструкції з деплою (мінімальні)..

### Прийнятні спрощення для MVP
- Лише числові карти; жодних спецкарт.
- In‑memory стан без персистентності між рестартами.
- Відсутність матчмейкінгу; ручне створення/приєднання через Activity.

### Відкриті параметри (узгоджено «ОК»)
- 2–6 гравців, стартова рука 7, «draw 1 і можна одразу зіграти», Activity з голосового каналу, без БД у MVP.



## Технічний план реалізації (поетапно)

Нижче наведено послідовний план реалізації та критерії готовності (очікувані результати) для кожного етапу.

### Етап 0 — Інфраструктура (готово)
- Фронт на Vercel (Vite) + serverless `/api/token` для обміну OAuth‑коду.
- WS‑бекенд на Fly.io: HTTP GET `/health`, WS `/ws` (echo + ping/pong), `ALLOWED_ORIGIN` для безпеки.
- Зв’язок фронт ↔ бек через `VITE_REALTIME_URL`.
- Очікуваний результат: у Discord видно Hello World; в консолі є “Discord SDK is ready”; `POST /api/token` повертає коректні 4xx/2xx; `wss://…/ws` відповідає hello/pong.

### Етап 1 — Підключення клієнта до WS + мінімальне лобі
- Протокол оболонки повідомлень: `{ type, requestId?, data }`.
- Події клієнт→сервер: `create_room`, `join_room`, `leave_room`, `heartbeat`.
- Події сервер→клієнт: `room_created`, `joined`, `left`, `error`, `heartbeat_ack`.
- Клієнт: WS‑конектор (автопідключення, стани Connected/Reconnecting), отримання контексту з Discord SDK (user/channel/guild), просте лобі (поле Room ID + кнопки Create/Join/Leave + лог подій).
- Сервер: in‑memory реєстр кімнат, маппінг сокет↔playerId, heartbeat/timeout.
- Очікуваний результат: 2 клієнти можуть створити кімнату, приєднатись/вийти; сервер розсилає `joined/left`.

### Етап 2 — Ядро правил UNO (MVP) (готово)
- Модель карти: `color ∈ {red, green, blue, yellow}`, `value ∈ 0..9`.
- Колода: 1×0 та 2×(1–9) на колір; тасування (optional seeded).
- Стан гри: `players`, `hands`, `drawPile`, `discardTop`, `currentTurn`, `phase`.
- Логіка: роздача 7; перша карта в `discardTop` — числова; валідний хід — збіг за кольором або числом; якщо немає ходу — `draw 1`, можна одразу зіграти, інакше `pass`; перемога — порожня рука.
- Події клієнт→сервер: `start`, `play`, `draw`, `pass`.
- Відповіді сервер→клієнт: `snapshot` (повний стан для гравця), `patch` (диф), `invalid_move`, `winner`.
- Приватність: чужі руки як лічильники карт, без розкриття вмісту.
- Очікуваний результат: повноцінна партія 2 гравців проходить без помилок локально й у проді.

### Етап 3 — Реконект і життєвий цикл сесій (готово)
- Ідентифікація гравця за Discord userId, повторне підключення до тієї ж сесії.
- На реконекті сервер надсилає актуальний `snapshot`; таймаут AFK/auto‑pass; авто‑cleanup кімнат.
- Очікуваний результат: перезавантаження вкладки не ламає матч; пізній join отримує валідний стан.

### Етап 4 — UI столу (мінімально достатній)
- Лобі: список гравців, статус ready, кнопка Start для хоста.
- Стіл: рука гравця, верхня карта відбою, індикатор поточного ходу, кнопки play/draw/pass, підсвітка валідних ходів.
- Нотифікації про помилки/статуси.
- Очікуваний результат: матч можна повністю зіграти без користування консоллю.

### Етап 5 — Надійність і безпека
- Валідація JSON подій (наприклад, Zod або ручні схеми) на сервері.
- Rate limiting per socket/room, захист від flood.
- Логи уніфіковані: час, тип події, roomId, playerId, `requestId` для кореляції.
- Очікуваний результат: помилкові/шкідливі події не валять сервер; клієнт отримує зрозумілі `error`.

### Етап 6 — Тести й інструменти
- Юніт‑тести правил: роздача, валідність ходу, перемога.
- Навантажувальна перевірка: 1 кімната × до 6 гравців (емулятори клієнтів).
- Інтеграційні сценарії: happy path, реконект/late‑join.
- Очікуваний результат: зелений набір тестів; перевірені ключові сценарії.

### Етап 7 — Прод/опс
- Автодеплой WS (кнопка/CLI), авто‑стоп при простої (free), швидкий redeploy/rollback.
- Моніторинг: health, логи Fly; логи функцій Vercel.
- Документація: README із запуском/деплоєм; перелік змінних середовища.
- Очікуваний результат: стабільний деплой, зрозуміла інструкція, швидке відновлення.

### Етап 8 — (Опційно) Покращення
- Сидований shuffle для репрод’юсибельності.
- Збереження реплеїв/логів у недорогому сховищі.
- Альтернативні платформи (Cloudflare Durable Objects) за потреби.
- Очікуваний результат: краща відтворюваність, діагностика та масштабованість без зміни базового UX.
